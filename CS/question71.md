#### Redis에 대하여
- In-Memory Data Structure Store
- 오픈 소스이다.(BSD 3 License!!)
- 다양한 자료 구조를 지원한다.
  -  Strings, set ,Sorted-set, hahses, list
  -  Hyperloglog, bitmap
  -  Stream
- **TMI 레디스 소스 코드를 고칠 수 있는 사람은 단 1명이다!**

##### Cache를 쓰는 이유
- Cache: 나중에 요청된 결과를 미리 저장해두었다가 빠르게 제공해주는 것을 의미
- 접근 속도가 굉장히 빠르기 때문에 사용한다.
- 그래서 어디서 어떻게 주로 사용하냐!(여러가지 전략)
  - DB 안에 많은 데이터가 있는데, 이 때 주로 디스크에 내용이 저장되게 된다. DB에 접근하기 전 위치에 두어 캐시저장소를 먼저
  접근하고, 그 다음에 DB에 접근하도록 한다.(Look Aside)
  - 웹 서버가 캐시에만 접근하게 해서, 캐시에 먼저 결과를 저장했다가 특정 시점마다 캐시에서 DB에 접근하도록 한다.(Write Back) / 근데 이렇게 쓰면 메모리에 데이터를 저장하기 때문에
데이터가 유실될 위험이 있다!

#### 왜 Collection이 중요한가?
- Redis는 Collection을 제공한다.
- 개발의 편의성이 증가하고, 난이도가 감소한다.
- 예를 들어 랭킹 서버를 직접 구현한다면???(리더보드)
  - Redis를 사용하는 것이 훨씬 좋다. DB에 접근한다면 결국엔 디스크를 사용하는 것이다. 그러면 사용자가 많아질수록 속도가 저하된다.
  - Redis의 Sorted Set을 사용하여 랭킹(리더보드)을 구현할 수 있다.
- 또 친구 리스트를 관리한다면?
  - 친구 리스트를 Key/Value 형태로 저장할 경우: 두 개의 작업이 독립적이여야 하는데, 독립적이지 못할 수 있다.
  트랜잭션이 각각 독립적으로 동작하지 못할 수 있는 것이다.(동시성 이슈)
  - 그러나 Redis의 자료구조는 원자성을 가진다! 그래서 해당 문제를 피할 수 있다.
- Collection 이용을 통해 개발 시간을 단축시키고, 문제를 줄여줄 수 있다!


#### 그래서 Redis를 어디에 써야 할까요?
- Remote Data Store: 여러 서버에서 데이터를 공유하고 싶을 때
- 인증 토큰 저장할 때(Strings 또는 Hash)
- Ranking 보드로 사용할 때(Sorted Set)
- 유저 API Limit

#### Redis의 Collections
- Strings: Key / Value로 저장
- List: 중간 삽입이 안된다, 중복 허용
- Set: 중복을 허용하지 않는다. 데이터가 있는지 없는지만 체크하는 용도!
- Sorted Set: Score를 통해 정렬이 가능하다. 랭킹에 따라 순서가 바뀌길 바란다면! 근데 Score는 double 타입이기 때문에 값이 정확하지 않을 수 있다.
- Hash: Key/Value 안에 sub key/value가 존재하는 것이다.

##### Collections에 대한 주의사항
- 하나의 컬렉션에 너무 많은 데이터를 담는 것은 좋지 않다.(몇 천개 수준을 유지하는 것이 좋다.)
- Expire의 범위는 Collection의 전체 데이터이다.

#### Redis 운영에서의 주의 사항
- 메모리 관리를 잘하자.
- O(N) 관련 명령어는 주의하자
- Replication

##### 메모리 관리를 잘해야 하는 이유
- 인 메모리 데이터베이스이기 때문에 물리적인 메모리 크키 이상을 사용할 수 없다.
  - Swap(메모리가 부족할 때, 메모리 페이지를 임시로 디스크에 저장해 놓고, 필요하면 다시 이를 로딩시키고)이 한 번이라도 발생한 메모리 페이지는 계속 Swap이 발생한다.
- Max 메모리를 설정(사용할 메모리에 대한 한계를 설정)하더라도 이보다 더 사용할 가능성이 크다.
  - 메모리 할당을 구현체에 의존한다. 그래서 정확한 사용량을 알 수 없어 더 사용할 수 있다는 것이다.
- 큰 메모리를 사용하는 인스턴스 하나보다 적은 메모리를 사용하는 인스턴스 여러 개가 안전하다.
  -  redis는 필연적으로 fork()를 하는데(copy-on-write(COW)으로 실제 메모리 페이지가 수정될 ), 클수록 fork()가 호출되면 상당한 컴퓨터 자원을 필요로 하게 되고, fork() 자체의 속도 저하를 초래한다.
fork() 동안 Redis는 쓰기 작업을 처리할 수 없어 클라이언트의 요청 처리가 지연되거나 타임아웃이 발생할 수 있다.
  - 따라서 메모리를 분산하여 fork() 부담을 덜고, 여러 인스턴스로 격리하여 성능 저하와 시스템 불안정을 최소화 할 수 있다.
  - **유사한 크기의 데이터를 가지는 경우가 유리하다!**
- 메모리가 부족하다면?  메모리가 많은 장비로 옮겨라! 있는 데이터를 줄여라!(사용 빈도가 낮은 데이터를 제거)
- Hash -> Hash Table을 사용 / Sorted Set -> Skiplist와 Hash Table을 사용 / Set -> Hash Table을 사용 하는 방식으로 메모리 사용을 효율화 할 수 있다.
그러나...! 위 자료구조들은 오히려 메모리를 생각보다 많이 사용할 수 있기 때문에 선형으로 저장하는 Ziplist를 활용하는 방법도 있다.
  - 인 메모리 특성상  적은 개수라면 선형탐색을 하더라도 빠르기 때문이다!
##### O(N) 관련 명령어를 주의하자
- Redis는 싱글 스레드로 동작하기 때문이다! (Redis가 동시에 처리할 수 있는 명령은 1개이다.)
- 그래서 하나의 요청이 길어지면 뒤의 요청들의 대기 시간이 길어진다.(KEYS, FLUSHALL, FLUSHDB, Delete COlLECTIONS, Get All Collections 등등)
- 엄청난 실수 사례:
  - Key가 백만개 이상인데 이를 KEYS 명령을 사용하는 경우
  - 모니터링 스크립트가 일초에 한 번씩 KEYS를 호출함: scan 명령을 사용하는 것으로 대체하자!(긴 명령을 짧은 여러 번의 명령으로 바꿀 수 있다.)
  - Collection의 모든 Item을 가져올 때: Collection의 일부만 가져 오거나, 큰 Collection을 작은 Collection으로 나눠서 저장한다.
  - Spring Security Oauth Redis Token Store 이슈: Access Token 저장을 List(O(N))을 통해서 한다.(검색, 삭제 시 모든 Item을 찾아봐야 하기 때문)
  최근에는 Set(O(1))을 통해 가져오도록 패치됨

##### Redis Replication
- Replication: 하나의 Redis 서버에서 다른 서버로 데이터를 복제하는 기능이다! 주로 Master(쓰기 작업)-Slave(읽기 작업 처리) 구조를 사용한다.
- 비동기로 동작한다: Replication Lag(복제 지연)가 발생할 수 있다.(슬레이브가 마스터의 업데이트를 따라잡을 수 없을 때)
  - Replication Lag이 많이 발생하면 부하가 증가하여 Master가 Slave의 연결을 끊어버린다.
  - Master-Slave에서 Replicaof-slaveof로 변경했다.(둘 다 사용 가능)

https://www.youtube.com/watch?v=mPB2CZiAkKM 54:43부터 다시 
